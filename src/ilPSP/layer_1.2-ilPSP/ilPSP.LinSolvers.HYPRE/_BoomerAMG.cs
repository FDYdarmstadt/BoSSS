/* =======================================================================
Copyright 2017 Technische Universitaet Darmstadt, Fachgebiet fuer Stroemungsdynamik (chair of fluid dynamics)

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

using System;
using System.Collections.Generic;
using System.Text;

namespace ilPSP.LinSolvers.HYPRE {

    /// <summary>
    /// Boomer AMG Multigrid cycle
    /// </summary>
    public enum CycleType {
        
        /// <summary>
        /// guess
        /// </summary>
        V_Cycle = 1,


        /// <summary>
        /// guess
        /// </summary>
        W_Cycle = 2
    }

    /// <summary>
    /// Algebraic multigrid smoother type
    /// </summary>
    public enum RelaxType {
        /// <summary>
        /// 
        /// </summary>
        Jacobi = 0,

        /// <summary>
        /// Gauss-Seidel, sequential (very slow!)
        /// </summary>
        GaussSeidelSeq = 1,

        /// <summary>
        /// Gauss-Seidel, interior points in parallel, boundary sequential (slow!)
        /// </summary>
        GaussSeidel = 2,
    
        /// <summary>
        /// hybrid Gauss-Seidel or SOR, forward solve
        /// </summary>
        hybGaussSeidel_or_SOR_FWD = 3,

        /// <summary>
        /// hybrid Gauss-Seidel or SOR, backward solve
        /// </summary>
        hybGaussSeidel_or_SOR_BKWD = 4,

        /// <summary>
        /// hybrid chaotic Gauss-Seidel (works only with OpenMP)
        /// </summary>
        hybChaGaussSeidel = 5,

        /// <summary>
        /// hybrid symmetric Gauss-Seidel or SSOR
        /// </summary>
        hybSymmGaussSeidel_or_SSOR = 6,


        /// <summary>
        /// Gaussian elimination (only on coarsest level)
        /// </summary>
        GaussElim = 9
    }

    /// <summary>
    /// Multigrid cycle type
    /// </summary>
    public enum CycleLevel {
        /// <summary> </summary>
        finest_level = 0,

        /// <summary> </summary>
        down_cycle = 1,

        /// <summary> </summary>
        up_cycle = 2,

        /// <summary> </summary>
        corasest_level = 3
    }

    /// <summary>
    /// (Optional) Sets the number of sweeps at a specified cycle. There are the following options for k:
    /// the down cycle if k=1
    /// the up cycle if k=2
    /// the coarsest level if k=3.
    /// the finest level if k=0
    /// </summary>
    public enum CycleNumSweepsLevels
    {
        /// <summary>the down cycle</summary>
        down_cycle = 1,
        /// <summary>the up cycle</summary>
        up_cycle = 2,
        /// <summary>the coarsest level</summary>
        coarsest = 3,
        /// <summary>the finest level</summary>
        finest = 0
    }

    /// <summary>
    /// 0 CLJP-coarsening (a parallel coarsening algorithm using independent sets.
    /// 1 classical Ruge-Stueben coarsening on each processor, no boundary treatment (not recommended!)
    /// 3 classical Ruge-Stueben coarsening on each processor, followed by a third pass, which adds coarse
    /// points on the boundaries
    /// 6 Falgout coarsening (uses 1 first, followed by CLJP using the interior coarse points
    /// generated by 1 as its first independent set)
    /// 7 CLJP-coarsening (using a fixed random vector, for debugging purposes only)
    /// 8 PMIS-coarsening (a parallel coarsening algorithm using independent sets, generating
    /// lower complexities than CLJP, might also lead to slower convergence)
    /// 9 PMIS-coarsening (using a fixed random vector, for debugging purposes only)
    /// 10 HMIS-coarsening (uses one pass Ruge-Stueben on each processor independently, followed
    /// by PMIS using the interior C-points generated as its first independent set)
    /// 11 one-pass Ruge-Stueben coarsening on each processor, no boundary treatment (not recommended!)
    /// </summary>
    public enum CoarseTypes {
        /// <summary>
        /// CLJP-coarsening (a parallel coarsening algorithm using independent sets).
        /// </summary>
        cljp = 0,
        /// <summary>
        /// Classical Ruge-Stueben coarsening on each processor, no boundary treatment (not recommended!)
        /// </summary>
        ruge_stueb_without_boundarys = 1,
        /// <summary>
        /// Classical Ruge-Stueben coarsening on each processor, followed by a third pass, which adds coarse
        /// points on the boundaries.
        /// </summary>
        ruge_stueb_with_boundarys=3,
        /// <summary>
        /// Falgout coarsening (uses 1 first, followed by CLJP using the interior coarse points
        /// generated by 1 as its first independent set).
        /// </summary>
        falgout = 6,
        /// <summary>
        /// CLJP-coarsening (using a fixed random vector, for debugging purposes only)
        /// </summary>
        cljp_fixed = 7,
        /// <summary>
        /// PMIS-coarsening (a parallel coarsening algorithm using independent sets, generating
        /// lower complexities than CLJP, might also lead to slower convergence)
        /// </summary>
        pmis = 8,
        /// <summary>
        /// PMIS-coarsening (using a fixed random vector, for debugging purposes only)
        /// </summary>
        pmis_fixed = 9,
        /// <summary>
        /// HMIS-coarsening (uses one pass Ruge-Stueben on each processor independently, followed
        /// by PMIS using the interior C-points generated as its first independent set)
        /// </summary>
        hmis = 10,
        /// <summary>
        /// One-pass Ruge-Stueben coarsening on each processor, no boundary treatment (not recommended!)
        /// </summary>
        ruge_stueb_one_pass = 11
    }
    /// <summary>
    /// measure type defines whether local (measure type = 0, default) or 
    /// global measures (measure type = 1) are used within the coarsening algorithm. 
    /// This feature is ignored for the CLJP and the Falgout coarsening.
    /// </summary>
    public enum MeasureTypes
    {
        /// <summary>
        /// 
        /// </summary>
        local = 0,
        
        /// <summary>
        /// 
        /// </summary>
        global = 1
    }
    
    /// <summary>
    /// (Optional) Defines in which order the points are relaxed
    /// 0 - the points are relaxed in natural or lexicographic order on each processor
    /// 1 - CF-relaxation is used, i.e on the fine grid and the down cycle the coarse points are relaxed first,
    /// followed by the fine points; on the up cycle the F-points are relaxed first, followed by the C-points.
    /// On the coarsest level, if an iterative scheme is used, the points are relaxed in lexicographic order.
    /// Note: Default is 1
    /// </summary>
    public enum _RelaxOrder{
        /// <summary>
        /// normal(0) - the points are relaxed in natural or lexicographic order on each processor
        /// </summary>
        normal = 0,
        /// <summary>
        /// cf_relax(1) - CF-relaxation is used (default).
        /// </summary>
        cf_relax = 1
    }


    /// <summary>
    /// BoSSS interface to BoomerAMG solver
    /// </summary>
    public class BoomerAMG : Solver, IImplicitPrecond {
        
        /// <summary>
        /// 
        /// </summary>
        protected override void CreateSolver() {
            HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGCreate(out m_Solver));
            if (m_Solver.p == IntPtr.Zero)
                throw new ApplicationException("Solver initialization failed");
            PrintLevel = 0;
        }

        int m_PrintLevel = 0;

        /// <summary>
        /// turns hypre-internal printing of PCG informative messages
        /// on/off;
        /// </summary>
        public int PrintLevel {
            get {
                return m_PrintLevel;
            }
            set {
                int d = value;
                if (d < 0 || d > 2)
                    throw new ArgumentOutOfRangeException();
                m_PrintLevel = d;
                HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGSetPrintLevel(m_Solver, d));
            }
        }


        /// <summary>
        /// ctor
        /// </summary>
        public BoomerAMG() {
            base.m_NativeSolverFuncPtr = Wrappers.BoomerAMG.my.Delegate2FunctionPointer[Wrappers.BoomerAMG.my.HYPRE_BoomerAMGSolve];
            base.m_NativeSetupFuncPtr  = Wrappers.BoomerAMG.my.Delegate2FunctionPointer[Wrappers.BoomerAMG.my.HYPRE_BoomerAMGSetup];
        }

        /// <summary>
        /// calls <see cref="Dispose"/>;
        /// </summary>
        ~BoomerAMG() {
            Dispose();
        }

        /// <summary>
        /// destroys the HYPRE object, if not allready done;
        /// </summary>
        public override void Dispose() {
            if (m_Solver.p != IntPtr.Zero) {
                HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGDestroy(m_Solver));
                m_Solver.p = IntPtr.Zero;
            }
            base.Dispose();
        }
        
        /// <summary>
        /// 
        /// </summary>
        internal Wrappers.T_Solver HypreSolver { get { return m_Solver; } }

        /// <summary>
        /// Defines threshold for ParaSAILS. For further explanation see description of ParaSAILS.
        /// </summary>
        public double Threshold {
            set {
                HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGSetThreshold(m_Solver, value));
            }
            get {
                double r;
                HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGGetThreshold(m_Solver, out r));
                return r;
            }
        } // ok



        /// <summary>
        /// Sets AMG strength threshold. The default is 0.25. For 2d Laplace operators, 0.25 is a good value,
        /// for 3d Laplace operators, 0.5 or 0.6 is a better value. For elasticity problems, a large strength threshold,
        /// such as 0.9, is often better.
        /// </summary>
        public double StrongThreshold {
            set {
                 HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGSetStrongThreshold(m_Solver, value));
            }
            get {
                double r;
                HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGGetThreshold(m_Solver, out r));
                return r;
            }
        } // ok



        /// <summary>
        /// Sets/Gets maximum number of multigrid levels. The default is 25.
        /// </summary>
        public int MaxLevels {
            get {
                int r;
                HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGGetMaxLevels(m_Solver, out r));
                return r;
            }
            set {
                HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGSetMaxLevels(m_Solver, value));
            }
        } // ok



        /// <summary>
        /// Multigrid Cycle Type
        /// </summary>
        public CycleType CycleType {
            get {
                int ct;
                HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGGetCycleType(m_Solver, out ct));
                return (CycleType)ct;
            }
            set {
                HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGSetCycleType(m_Solver, (int)value));
            }
        } // ok

        /// <summary>
        /// (Optional) Defines the smoother to be used, for all levels (for setting individual levels,
        /// use <see cref="CycleRelaxType"/>);
        /// It sets the given smoother on the fine grid, the up and the
        /// down cycle and sets the smoother on the coarsest level to Gaussian elimination (9). 
        /// The default is Gauss-Seidel;
        /// </summary>
        public RelaxType RelaxType {
            set {
                HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGSetRelaxType(m_Solver, (int)value));
            }
        } // ok


        /// <summary>
        /// (Optional) Defines the smoother at a given cycle.
        /// </summary>
        public _CycleRelaxType CycleRelaxType {
            get {
                return new _CycleRelaxType(m_Solver);
            }
        } // ok


        /// <summary>
        /// (Optional) Defines the smoother at a given cycle.
        /// </summary>
        public class _CycleRelaxType : IIndexedProperty<CycleLevel,RelaxType> {

            /// <summary>
            /// 
            /// </summary>
            /// <param name="solver"></param>
            internal _CycleRelaxType(Wrappers.T_Solver solver) {

                m_Solver = solver;
            }

            Wrappers.T_Solver m_Solver;

            /// <summary>
            /// set/get this property
            /// </summary>
            /// <param name="level"></param>
            /// <returns></returns>
            public RelaxType this[CycleLevel level] {
                get {
                    int k = (int)level;
                    int rt;
                    HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGGetCycleRelaxType(m_Solver, out rt, k));
                    return (RelaxType)rt;
                }
                set {
                    int k = (int)level;
                    int rt = (int)value;
                    HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGSetCycleRelaxType(m_Solver, rt, k));
                }
            }
        }


        /// <summary>
        /// Defines the relaxation weight for smoothed Jacobi and hybrid SOR on all levels.
        /// (for setting indivdual levels, use <see cref="_LevelRelaxWt"/>);
        /// </summary>
        public double RelaxWt {
            set {
                HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGSetRelaxWt(m_Solver, value));
            }
        } // ok


        /// <summary>
        /// relaxation weight on multigrid levels
        /// </summary>
        public _LevelRelaxWt LevelRelaxWt {
            get {
                return new _LevelRelaxWt(m_Solver); 
            }
        } // ok


        /// <summary>
        /// relaxation weight on multigrid levels
        /// </summary>
        public class _LevelRelaxWt : IIndexedProperty<int,double> {

            /// <summary>
            /// 
            /// </summary>
            /// <param name="solver"></param>
            internal _LevelRelaxWt(Wrappers.T_Solver solver) {

                m_Solver = solver;
            }

            Wrappers.T_Solver m_Solver;

            /// <summary>
            /// number of levels;
            /// </summary>
            public int NumLevels {
                get {
                    int nl;
                    HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGGetNumLevels(m_Solver, out nl));
                    return nl;
                }
            }


            /// <summary>
            /// (Optional) Defines the relaxation weight for smoothed Jacobi and hybrid SOR on the user defined level. Note
            /// that the finest level is denoted 0, the next coarser level 1, etc.;
            /// relax weight > 0: this assigns the given relaxation weight on specified level;
            /// relax weight = 0 the weight is determined on each level with the estimate 
            /// 3/(4* |D^(−1/2)*A*D^(−1/2)|), where D is the diagonal matrix of A (this should only be used with Jacobi);
            /// relax weight = -k: the relaxation weight is determined with at most k CG steps on specified level,
            /// this should only be used for symmetric positive definite problems;
            /// </summary>
            /// <param name="level"></param>
            /// <returns></returns>
            public double this[int level] {
                get {
                    if (level < 0 || level >= NumLevels)
                        throw new IndexOutOfRangeException();
                    double val;
                    HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGGetLevelRelaxWt(m_Solver, out val, level));
                    return val;
                }
                set {
                    if (level < 0 || level >= NumLevels)
                        throw new IndexOutOfRangeException();
                    HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGSetLevelRelaxWt(m_Solver, value, level));
                }
            }

        }

        /// <summary>
        /// Note that the Hypre BoomerAMG solver only supports relative tolerances,
        /// so the <see cref="Solver.ConvergenceType"/>-setting has no effect;
        /// </summary>
        public double Tolerance {
            get {
                double Tol;
                HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGGetTol(m_Solver, out Tol));
                return Tol;
            }
            set {
                HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGSetTol(m_Solver, value));
            }
        } // ok

        /// <summary>
        /// 
        /// </summary>
        public int MaxIterations {
            get {
                int MaxIter;
                HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGGetMaxIter(m_Solver, out MaxIter));
                return MaxIter;
            }
            set {
                HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGSetMaxIter(m_Solver, value));
            }
        } // ok

        /// <summary>
        /// fj
        /// </summary>
        protected override void CallSolver(out int NoOfIter, out bool Converged, IJVector Unknowns, IJVector Rhs) {
            if (m_Solver.p == IntPtr.Zero)
                throw new ApplicationException("solver not initialized");


            HypreException.Check(Wrappers.BoomerAMG.__HYPRE_BoomerAMGSetup(m_Solver, m_Matrix.m_ParCSR_matrix, Rhs.ParCRS_vector, Unknowns.ParCRS_vector));
            Wrappers.BoomerAMG.__HYPRE_BoomerAMGSolve(m_Solver, m_Matrix.m_ParCSR_matrix, Rhs.ParCRS_vector, Unknowns.ParCRS_vector);
            // We dont want to raise an exception for
            // a 'method did not converge'- or 'nomerical breakdown' - Error
            // that may occur in HYPRE
            Wrappers.Utilities.HYPRE_ClearAllErrors();                                            

            HypreException.Check(Wrappers.PCG.GetNumIterations(m_Solver, out NoOfIter));
            Converged = !(NoOfIter == MaxIterations);
        }

        /// <summary>
        /// (Optional) Sets a parameter to modify the definition of strength for diagonal dominant portions of the
        /// matrix. The default is 0.9. If max row sum is 1, no checking for diagonally dominant rows is performed.
        /// </summary>
        public double MaxRowSum
        {
            set
            {
                HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGSetMaxRowSum(m_Solver, value));
            }
            get
            {
                double MaxRowSum;
                HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGGetMaxRowSum(m_Solver,out MaxRowSum));
                return MaxRowSum;
            }
        } // ok

        /// <summary>
        /// (Optional) Defines which parallel coarsening algorithm is used.
        /// </summary>
        public CoarseTypes CoarseType
        {
            set
            {
                HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGSetCoarsenType(m_Solver, (int)value));
            }
            get
            {
                int coarsenType;
                HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGGetCoarsenType(m_Solver, out coarsenType));
                return (CoarseTypes)coarsenType;
            }
        } // ok

        /// <summary>
        /// (Optional)Defines whether local or global measures are used
        /// </summary>
        public MeasureTypes MeasureType
        {
            set
            {
                HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGSetMeasureType(m_Solver, (int)value));
            }
            get
            {
                int measureType;
                HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGGetMeasureType(m_Solver, out measureType));
                return (MeasureTypes)measureType;
            }
        } // ok



        /// <summary>
        /// (Optional) Sets the number of sweeps for all levels;
        /// There is no corresponding Get function, for setting/getting 
        /// individual levels use <see cref="CycleNumSweeps"/>;
        /// </summary>
        public int NumSweeps
        {
            set
            {
                HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGSetNumSweeps(m_Solver, (int)value));
            }
        } // ok;


        /// <summary>
        /// (Optional) Defines in which order the points are relaxed
        /// </summary>
        public _RelaxOrder RelaxOrder
        {
            set
            {
                HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGSetRelaxOrder(m_Solver, (int)value));
            }
            get
            {
                int relaxOrder;
                HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGGetRelaxOrder(m_Solver, out relaxOrder));
                return (_RelaxOrder) relaxOrder;
            }
        } // ok


        ///// <summary>
        ///// Defines the outer relaxation weight for hybrid SOR.
        ///// Note: This property will be phased out!!!!
        ///// Use OuterWt or LevelOuterWt instead.
        ///// </summary>
        //public unsafe double Omega {
        //    set {
        //        double val = value;
        //        Wrappers.BoomerAMG.HYPRE_BoomerAMGSetOmega(m_solver, &val);
        //    }
        //    get {
        //        double val;
        //        double* pt2val = &val;
        //        Wrappers.BoomerAMG.HYPRE_BoomerAMGGetOmega(m_solver, &pt2val);
        //        return val;
        //    }
        //}


        ///<summary>
        ///(Optional) Defines the outer relaxation weight for hybrid SOR and SSOR on all levels.
        /// omega > 0: this assigns the same outer relaxation weight omega on each level;
        /// omega = -k: an outer relaxation weight is determined with at most k CG steps on each level
        /// (this only makes sense for symmetric positive definite problems and smoothers, e.g. SSOR)
        /// Use <see cref="LevelOuterWt"/> to set/get individual levels;
        /// </summary>
        public double OuterWt
        {
            set {
                HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGSetOuterWt(m_Solver, value));
            }
        }

        /// <summary>
        /// (Optional) Defines the outer relaxation weight for hybrid SOR or SSOR on the user defined 
        /// level. Note that the finest level is denoted 0, the next coarser level 1, etc. 
        /// For nonpositive omega, the parameter is determined
        /// on the given level as described for HYPRE BoomerAMGSetOuterWt. The default is 1
        /// </summary>
        public _LevelOuterWt LevelOuterWt {
            get { 
                return new _LevelOuterWt(m_Solver); 
            }
        }


        /// <summary>
        /// <see cref="LevelOuterWt"/>
        /// </summary>
        public class _LevelOuterWt : IIndexedProperty<int,double> {

            internal _LevelOuterWt(Wrappers.T_Solver solver) {
                m_solver = solver;
            }

            Wrappers.T_Solver m_solver;

            /// <summary>
            /// number of levels;
            /// </summary>
            public int NumLevels {
                get {
                    int nl;
                    HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGGetNumLevels(m_solver, out nl));
                    return nl;
                }
            }



            /// <summary>
            /// (Optional) Defines the outer relaxation weight for hybrid 
            /// SOR or SSOR on the user defined level. Note that the finest level is denoted 0,
            /// the next coarser level 1, etc. For nonpositive omega, an outer relaxation weight is 
            /// determined with at most k CG steps on each level
            /// (this only makes sense for symmetric positive definite problems and smoothers, e.g. SSOR).
            /// The default is 1;
            /// </summary>
            /// <param name="level"></param>
            /// <returns></returns>
            public double this[int level] {
                get {
                    if (level < 0 || level >= NumLevels)
                        throw new IndexOutOfRangeException();
                    double val;
                    HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGGetLevelOuterWt(m_solver, out val, level));
                    return val;
                }
                set {
                    if (level < 0 || level >= NumLevels)
                        throw new IndexOutOfRangeException();
                    HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGSetLevelOuterWt(m_solver, value, level));
                }


            }

        }
 
        /// <summary>
        /// Sets the number of sweeps at a specified cycle.
        /// </summary>
        public _CycleNumSweeps CycleNumSweeps
        {
            get
            {
                return new _CycleNumSweeps(m_Solver);
            }
        } // ok

        /// <summary>
        /// <see cref="CycleNumSweeps"/>
        /// </summary>
        public class _CycleNumSweeps :  IIndexedProperty<CycleNumSweepsLevels, int>
        {
            internal _CycleNumSweeps(Wrappers.T_Solver solver)
            {
                m_solver = solver;
            }

            Wrappers.T_Solver m_solver;
            
            /// <summary>
            /// set/get this property
            /// </summary>
            /// <param name="level"></param>
            /// <returns></returns>
            public int this[CycleNumSweepsLevels level]{
                get
                {
                    int num_sweeps;
                    HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGGetCycleNumSweeps(m_solver, out num_sweeps, (int)level));
                    return num_sweeps;
                }
                set
                {
                    if (value < 0) throw new ArgumentException("Positive Integers only are allowed");
                    int num_sweeps = value;
                    HypreException.Check(Wrappers.BoomerAMG.HYPRE_BoomerAMGSetCycleNumSweeps(m_solver,num_sweeps, (int)level));
                }
            }

            //#region ITestInterface Members


            //public void DoNothing()
            //{
            //    throw new NotImplementedException();
            //}

            //#endregion
        } // ok
    }
}
